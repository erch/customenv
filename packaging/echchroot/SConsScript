# -*- mode:python -*-
#
# SConstruct file.
#


import distutils.util
import os
import os.path
import re
from SCons.Node.FS import Entry,FS
from SCons.Action import Action
import SCons.Builder
from SCons.Errors import BuildError
import fnmatch
import shutil
import stat
import cStringIO
import json
from Cheetah.Template import Template
import subprocess
import string

Import('env')
env['PROJECT'] = 'echchroot'
env['PLATFORM'] = distutils.util.get_platform()


env.SetDefault(BUILD_DIR = 'build')
buildDir=env.subst('$BUILD_DIR')
if not os.path.exists(buildDir):
    os.makedirs(buildDir)

# store signature files in the build directory
env.SetDefault(SCONS_SIGNFILE = os.path.join(buildDir,'.sconsign'))
SConsignFile(env.subst('$SCONS_SIGNFILE'))

class DebPkgBuilder:
    def __init__(self,env):
        self.collectMap = dict()
        self.env = env               
        self.project = env.subst('$PROJECT')
        self.buildDir = os.path.join(env.subst('$BUILD_DIR'),self.project)
        self.debianDir = os.path.join(self.buildDir,'DEBIAN')
        if not os.path.exists(self.debianDir):
            os.makedirs(self.debianDir)
        self.configuration = None
        self.templateRegex =  re.compile(r'(^.*)\.tmpl$')
        with open('version','r') as versFile:
            self.version = versFile.readline().strip()
        m = re.search('^(\d+)\.(\d+)\.(\d+)$',self.version)
        if m is None:
            raise BuildError(errstr='version file corrupted: %s' % (self.version),status=2,filename='version')
        self.versionMajor = int(m.group(1))
        self.versionMinor = int(m.group(2))
        self.versionRevision = int(m.group(3))
        print 'version: %s, major: %d, minor: %d, revision: %d' % (self.version, self.versionMajor,self.versionMinor,self.versionRevision)
        self.debpkgCommandTmpl = string.Template('fakeroot -- dpkg -b ${CONTROL_PATH} ${PCKG_PATH}')

    def parseConfig(self,confFile):
        conf = cStringIO.StringIO()
        with open(confFile,'r') as f:
            for line in [nocomment for nocomment in [l.strip() for l in f.readlines()] if nocomment[0] != '#']:                
                conf.write(line)
        self.configuration = json.loads(conf.getvalue())
        conf.close()

    def createControlFile(self):
        """
        read the configuration file and create the package control file
        """                    
        with open(os.path.join(self.debianDir,'control'),'w') as controlFile:
            controlFile.write('Version: %s\n' % self.version)
            if 'Package' in self.configuration:
                controlFile.write('Package: %s\n' % self.configuration['Package'])
            if 'Section' in self.configuration:
                controlFile.write('Section: %s\n' % self.configuration['Section'])
            if 'Priority' in self.configuration:
                controlFile.write('Priority: %s\n' % self.configuration['Priority'])
            if 'Architecture' in self.configuration:
                controlFile.write('Architecture: %s\n' % self.configuration['Architecture'])
            if 'Depends' in self.configuration:
                controlFile.write('Depends: %s\n' % ','.join(self.configuration['Depends']))
            if 'Maintainer' in self.configuration:
                controlFile.write('Maintainer: %s\n' % self.configuration['Maintainer'])
            if 'Description' in self.configuration:
                controlFile.write('Description: %s\n' % self.configuration['Description'])
        controlFile.close()                            

    def recFindFiles(self,srcDir,destDir,includes = ['*'],  excludes= []):
        """ Recursively find files in path matching include patterns list
        and not matching exclude patterns
        """
        sourcePath = str(srcDir)
        destPath = str(destDir)
        print 'recFindFiles for source: %s , with dest : %s, include: %s, exclude: %s' % (sourcePath,destPath,includes,excludes)
        res = list()
        if destPath[0] == os.sep:
            destPath = destPath[1:]
        for filename in os.listdir (sourcePath):            
            included = False
            for incPattern in includes:
                if fnmatch.fnmatch (filename, incPattern):
                    included = True
                    for exclPattern in excludes:
                        if fnmatch.fnmatch (filename, exclPattern):
                            included = False
                            break
                        break
           
            if included:
                fullname = os.path.join (sourcePath, filename)   
                if os.path.isdir (fullname):
                    res.extend(self.recFindFiles(fullname,os.path.join(destPath,filename),includes, excludes))
                else:
                    res.append([fullname,destPath])
                    print 'found %s , %s' % (fullname,destPath)
        return res

    def collectFiles(self,sourceRoot):
        """
        Collect all files to be put in the package
        """
        if 'install-scripts' in self.configuration:
            for instFileEntry in self.configuration['install-scripts']:
                source = os.path.join(sourceRoot,instFileEntry)               
                self.collectMap[source] = 'DEBIAN'
                print "added source to collectMap: %s , dest : DEBIAN"

        if 'resources' in self.configuration:            
            for resource in self.configuration['resources']:
                includes = ["*"]
                excludes = []
                print 'found resource : %s' % json.dumps(resource)
                if not 'source' in resource:
                    raise BuildError(errstr='No source for resource %s' % json.dumps(resource),status=2,filename='configuration')
                if not 'dest' in resource:
                    raise BuildError(errstr='No dest for resource: %s' % json.dumps(resource),status=2,filename='configuration')
                if 'includes' in resource:                    
                    includes = json.dumps(resource['includes'])
                if 'excludes' in resource:            
                    excludes = json.dumps(resource['excludes'])
                
                source = os.path.join(sourceRoot,resource['source'])
                if not os.path.exists(source):                   
                    raise  BuildError(errstr='source for resource not found: %s' % (source),status=2,filename='configuration') 
                dest = resource['dest']
                if os.path.isfile(source):
                    self.collectMap[source] = dest
                    print "added item to collectMap, source: %s, dest: %s" % (source,dest)
                else:              
                    for (src,dst) in self.recFindFiles(source,dest,includes,excludes):
                        print "adding item to collectionMap, source: %s, dest: %s" % (src,dst)
                        self.collectMap[src] = dst                        

    def replaceInFile(self,fileIn,DirOut,fileOut):
        defs = self.env['TEMPLATE_DEFS']        
        t = Template(file=fileIn, searchList=[defs])
        with open(os.path.join(DirOut,fileOut),'w') as fout:
            fout.write(str(t))

    def copyCollectedFiles(self):
        """
        copy collected files to the build directory after applying replacement string
        to template files.
        """                                  
        for source in self.collectMap:            
            destDir = os.path.join(self.buildDir,self.collectMap.get(source))                      
            if not os.path.exists(destDir):
                os.makedirs(destDir)  
            match = self.templateRegex.search(os.path.basename(source))
            if match:
                print 'replacing in file %s to dir %s , file %s' % (source,destDir,match.group(1))
                self.replaceInFile(source,destDir,match.group(1))
            else:
                shutil.copy2(source, destDir)

    def buildDebPkg(self,target, source, env):
        print 'target: %s, source: %s' % (target[0],source[0])        
        self.copyCollectedFiles()
        self.createControlFile()
        debpkgCommand = self.debpkgCommandTmpl.substitute(CONTROL_PATH=self.buildDir,PCKG_PATH=str(target[0]))
        cmdProc = subprocess.Popen(debpkgCommand,
                                   shell=True,                                   
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        stdout,stderr = cmdProc.communicate()    
        if cmdProc.returncode != 0:
            raise BuildError(errstr=stdout,status=2,filename=str(target[0]))        

    def getDebPackageName(self):
        name = self.configuration['Package']
        arch = self.configuration['Architecture']
        return "%s_%s_%s.deb" % (name,self.version,arch)

    def debPkgEmitter(self,target,source,env):
        """
        Reads the configuration file and emits the target and sources for the build
        of the debian package.
        The source is the directory from which all paths in the configuration are given.
        """
        try:
                sourceRoot = str(source[0])
                self.parseConfig(os.path.join(sourceRoot,str(target[0])))
                self.collectFiles(sourceRoot)
        
                dpkgFile = os.path.join(env.subst('$BUILD_DIR'),self.getDebPackageName())        
                return ([dpkgFile],self.collectMap.keys())
        except Exception as e:
            print str(e)
            raise e            



builder = DebPkgBuilder(env)
debPkgBuilder = Builder(action = Action(builder.buildDebPkg),target_factory=SCons.Node.FS.File,source_factory=SCons.Node.FS.Entry,emitter=builder.debPkgEmitter)

env.Append (BUILDERS = {'DEB_PKG' : debPkgBuilder})

#----------- 

env['TEMPLATE_DEFS'] =  {"title": "Hello World Example", "content": "Hello World!"}

env.DEB_PKG(target='deb.cfg',source='.')





